<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>runflow.core API documentation</title>
<meta name="description" content="Core module for runflow." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>runflow.core</code></h1>
</header>
<section id="section-intro">
<p>Core module for runflow.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Core module for runflow.&#34;&#34;&#34;

import enum
import inspect
import logging
import traceback
import asyncio
from functools import reduce

import networkx
from decouple import config
from tenacity import (
    retry,
    stop_after_delay,
    stop_after_attempt,
)

from . import hcl2, utils
from .errors import (
    RunflowAcyclicTasksError,
    RunflowSyntaxError,
)
from .hcl2_parser import LarkError
from .registry import get_task_class, register_task_class
from .utils import import_module

logger = logging.getLogger(__name__)


DEPENDS_ON_KEY = &#34;_depends_on&#34;


class TaskStatus(enum.Enum):
    &#34;&#34;&#34;Task execution status.&#34;&#34;&#34;

    PENDING = enum.auto()
    SUCCESS = enum.auto()
    FAILED = enum.auto()
    CANCELED = enum.auto()


class TaskResult:
    &#34;&#34;&#34;Task execution result.&#34;&#34;&#34;

    def __init__(self, status):
        self.status = status
        self._result = None
        self._exception = None

    @property
    def result(self):
        &#34;&#34;&#34;Get task result.&#34;&#34;&#34;
        if self._exception:
            raise ValueError(
                &#34;Task has no result due to a failed run.&#34;
            ) from self._exception
        return self._result

    @result.setter
    def result(self, _result):
        &#34;&#34;&#34;Set task result.&#34;&#34;&#34;
        self.status = TaskStatus.SUCCESS
        self._result = _result

    @property
    def exception(self):
        &#34;&#34;&#34;Get task exception.&#34;&#34;&#34;
        if self._result:
            raise ValueError(&#34;Task has no exception due to a successful run.&#34;)
        return self._exception

    @exception.setter
    def exception(self, _exception):
        &#34;&#34;&#34;Set task exception.&#34;&#34;&#34;
        self.status = TaskStatus.FAILED
        self._exception = _exception


class Task:
    &#34;&#34;&#34;Task object maintains the running status.&#34;&#34;&#34;

    def __init__(self, type, runner, name, payload):
        self.type = type
        self.runner = runner
        self.name = name
        self.payload = payload
        self.namespace = &#34;&#34;

    def __repr__(self):
        return (
            f&#34;Task(type={self.type}, &#34;
            f&#34;name={self.name}, &#34;
            f&#34;payload={self.payload})&#34;
        )

    def __str__(self):
        return (
            f&#34;{self.namespace}{self.namespace and &#39; &gt; &#39; or &#39;&#39;}&#34;
            f&#34;task.{self.type}.{self.name}&#34;
        )

    def __hash__(self):
        return hash(repr(self))

    def __eq__(self, o):
        return self.type == o.type and self.name == o.name

    def set_namespace(self, namespace):
        self.namespace = namespace

    def should_run(self, context):
        return all(
            hcl2.evaluate(depends_on, context)
            for depends_on in self.payload.get(DEPENDS_ON_KEY, [])
        )

    def should_timeout(self, task, context):
        if &#34;_timeout&#34; not in self.payload:
            return None
        _timeout = hcl2.evaluate(self.payload[&#34;_timeout&#34;], context)
        assert isinstance(_timeout, (int, float))
        return _timeout

    def should_rerun(self, task, context):  # pylint: disable=too-many-branches
        if &#34;_retry&#34; not in self.payload:
            return task.run

        _retry = hcl2.evaluate(self.payload.get(&#34;_retry&#34;, {}), context)
        _retry_params = {}
        stop_after = _retry.get(&#34;stop_after&#34;, &#34;1 times&#34;)
        stopers = []
        for _stop_after in stop_after.split(&#34;|&#34;):
            _stop_after = _stop_after.strip()
            if &#34;times&#34; in _stop_after:
                attempts = int(_stop_after.replace(&#34;times&#34;, &#34;&#34;).strip())
                stoper = stop_after_attempt(attempts)
            elif &#34;seconds&#34; in _stop_after:
                seconds = float(_stop_after.replace(&#34;seconds&#34;, &#34;&#34;).strip())
                stoper = stop_after_delay(seconds)
            else:
                raise ValueError(f&#34;invalid _retry.stop_after: {_stop_after}&#34;)
            stopers.append(stoper)

        _retry_params[&#34;stop&#34;] = reduce(lambda a, b: a | b, stopers)
        _retry_params[&#34;wait&#34;] = _retry.get(&#34;wait&#34;, None)
        _retry_params[&#34;reraise&#34;] = True
        return retry(**_retry_params)(task.run)

    def eval_payload(self, context):
        return hcl2.evaluate(
            {k: v for k, v in self.payload.items() if not k.startswith(&#34;_&#34;)},
            context,
        )

    async def run(self, context):
        &#34;&#34;&#34;Run a task.&#34;&#34;&#34;
        if self.type == &#34;hcl2_template&#34;:
            context = dict(
                context,
                **hcl2.evaluate(self.payload.get(&#34;context&#34;, {}), context),
            )

        if not self.should_run(context):
            logger.info(&#39;&#34;%s&#34; is canceled due to falsy deps.&#39;, str(self))
            return TaskResult(TaskStatus.CANCELED)

        _payload = self.eval_payload(context)
        context[&#34;task&#34;][self.type][self.name].update(_payload)

        task_result = TaskResult(TaskStatus.PENDING)

        try:
            logger.info(&#39;&#34;%s&#34; is started.&#39;, str(self))
            if isinstance(self.runner, Flow):
                task = self.runner.as_task(_payload)
            else:
                task = self.runner(**_payload)

            if isinstance(task, FlowRunTask):
                task.namespace = str(self)

            task_run = self.should_rerun(task, context)
            task_result.result = (
                await asyncio.wait_for(
                    task_run()
                    if inspect.iscoroutinefunction(task.run)
                    else utils.to_thread(task_run),
                    timeout=self.should_timeout(task, context),
                )
                or {}
            )
            task_result.result.update(_payload)
            logger.info(&#39;&#34;%s&#34; is successful.&#39;, str(self))
        except Exception as err:  # pylint: disable=broad-except
            task_result.exception = err
            logger.info(&#39;&#34;%s&#34; is failed.&#39;, str(self))
            traceback.print_exc()

        return task_result


class FlowRunTask:
    def __init__(
        self,
        path=None,
        source=None,
        module=None,
        flow=None,
        vars=None,
        export=None,
    ):
        self.path = path
        self.source = source
        self.module = module
        self.flow = flow
        self.vars = vars or {}
        self.export = export or []
        self.namespace = &#34;&#34;

    async def run(self):
        flow = Flow.load(
            path=self.path,
            source=self.source,
            module=self.module,
            flow=self.flow,
        )
        for task in flow:
            task.set_namespace(self.namespace)

        flow_context = await flow.run(vars=self.vars)

        if flow.exception:
            raise flow.exception

        return {
            key: hcl2.evaluate(hcl2.loads(value, &#34;eval&#34;), flow_context)
            for export in self.export
            for key, value in export.items()
        }


class SequentialRunner:
    &#34;&#34;&#34;This runner runs the flow tasks sequentially.&#34;&#34;&#34;

    def __init__(self, flow):
        self.flow = flow
        self.results = {}

    def check_depends_on(self, task):
        for upstream_task in self.flow.graph.predecessors(task):
            if self.results[upstream_task].status in (
                TaskStatus.FAILED,
                TaskStatus.CANCELED,
            ):
                return False
        return True

    async def run_task(self, task, context):
        if not self.check_depends_on(task):
            logger.info(
                &#39;&#34;%s&#34; is canceled due to previous task failed run.&#39;,
                f&#34;task.{task.type}.{task.name}&#34;,
            )
            return TaskResult(TaskStatus.CANCELED)

        task_result = await task.run(context)

        if task_result.status == TaskStatus.SUCCESS:
            context[&#34;task&#34;][task.type][task.name] = task_result.result

        return task_result

    async def run(self, context):
        &#34;&#34;&#34;Run flow tasks.&#34;&#34;&#34;
        for task in self.flow:
            self.results[task] = await self.run_task(task, context)


# pylint: disable=too-many-public-methods
class Flow:
    &#34;&#34;&#34;Flow object manages the flow graph and the order of task executions.&#34;&#34;&#34;

    def __init__(self, name, runner_cls=None):
        self.name = name
        self.graph = networkx.DiGraph()
        self.runner = (runner_cls or SequentialRunner)(self)
        self.vars = {}
        self.functions = {}

    def __iter__(self):
        &#34;&#34;&#34;Iterate through all tasks in a dependent order.&#34;&#34;&#34;
        try:
            yield from networkx.topological_sort(self.graph)
        except networkx.exception.NetworkXUnfeasible as err:
            raise RunflowAcyclicTasksError(str(err)) from err

    @property
    def exception(self):
        return next(
            (
                task_result.exception
                for task_result in self.runner.results.values()
                if task_result.status == TaskStatus.FAILED
            ),
            None,
        )

    @classmethod
    def from_spec(cls, source):
        &#34;&#34;&#34;Load flow from a .hcl file content.&#34;&#34;&#34;
        try:
            flow = hcl2.loads(source)
        except LarkError as err:
            raise RunflowSyntaxError(str(err)) from err

        assert &#34;flow&#34; in flow, &#34;Need a flow block&#34;
        assert len(flow[&#34;flow&#34;]) == 1, &#34;Runflow spec should have only one flow&#34;

        flow_spec = flow[&#34;flow&#34;][0]
        flow_name, flow_body = next(iter(flow_spec.items()))
        flow = cls(name=flow_name)
        flow.load_flow_spec_body(flow_body)
        return flow

    @classmethod
    def from_specfile(cls, path):
        &#34;&#34;&#34;Load flow from a given file path.&#34;&#34;&#34;
        with open(path) as file:
            flow_spec = file.read()
        return cls.from_spec(flow_spec)

    @classmethod
    def load(cls, path=None, source=None, module=None, flow=None):
        if path:
            return Flow.from_specfile(path)

        if source:
            return Flow.from_spec(source)

        if module:
            return import_module(module)

        return flow

    def add_task(self, task):
        &#34;&#34;&#34;Add task to flow graph.&#34;&#34;&#34;
        self.graph.add_node(task)

    def set_dependency(self, task, depends_on):
        &#34;&#34;&#34;Let `task` depends on `depends_on`,

        e.g. `depends_on` is a predecessor edge of `task`.

        &#34;&#34;&#34;
        self.graph.add_edge(depends_on, task)

    def set_default_var(self, name, value):
        &#34;&#34;&#34;Set default value for variable.&#34;&#34;&#34;
        self.vars[name] = value

    def load_function(self, func_name, import_string):
        &#34;&#34;&#34;Load the imported function to task func namespace.&#34;&#34;&#34;
        function = utils.import_module(import_string)
        self.functions[func_name] = function

    # pylint: disable=no-self-use
    def load_flow_tasks_from_spec(self, tasks_spec):
        &#34;&#34;&#34;Load the `task` blocks.&#34;&#34;&#34;
        for task_spec in tasks_spec:
            for task_type in task_spec:
                task_class = get_task_class(task_type)
                for task_name in task_spec[task_type]:
                    task_payload = dict(task_spec[task_type][task_name])
                    yield Task(task_type, task_class, task_name, task_payload)

    def load_task_by_task_reference(self, depends_on):
        &#34;&#34;&#34;Find task by a reference like `task.TASK_TYPE.TASK_NAME`.&#34;&#34;&#34;
        task_key = depends_on.split(&#34;.&#34;)
        assert len(task_key) == 3 and task_key[0] == &#34;task&#34;

        _, task_type, task_name = task_key

        for task in self.graph.nodes:
            if task.type == task_type and task.name == task_name:
                return task

        raise RunflowSyntaxError(
            f&#34;Task depends on {task_key} &#34;
            f&#34;but the dependent task does not exist&#34;
        )

    def load_flow_tasks_dependencies(self, task):
        &#34;&#34;&#34;Find task dependencies.&#34;&#34;&#34;
        deps_set = set()
        for key, value in task.payload.items():
            hcl2.resolve_deps(key, deps_set)
            hcl2.resolve_deps(value, deps_set)

        for dep in deps_set:
            yield self.load_task_by_task_reference(dep)

    def set_tasks_dependencies(self):
        &#34;&#34;&#34;Walk the task graph and sort out the task dependencies.&#34;&#34;&#34;
        for task in self.graph.nodes:
            explicit_deps = self.load_flow_tasks_dependencies(task)
            for dep in explicit_deps:
                self.set_dependency(task, dep)

    def load_flow_variables(self, vars_spec):
        &#34;&#34;&#34;Load the `variable` block.&#34;&#34;&#34;
        for var_spec in vars_spec:
            var_name = next(iter(var_spec.keys()))
            var_value_spec = next(iter(var_spec.values()))
            var_value = config(
                f&#34;RUNFLOW_VAR_{var_name}&#34;, default=None
            ) or var_value_spec.get(&#34;default&#34;, None)
            var_required = var_value_spec.get(&#34;required&#34;)
            if var_required and var_value is None:
                raise NameError(f&#34;{var_name} is required but not provided.&#34;)
            self.set_default_var(var_name, var_value)

    # pylint: disable=no-self-use
    def load_flow_imported_tasks(self, tasks):
        &#34;&#34;&#34;Load the `import.tasks` attribute.&#34;&#34;&#34;
        for task_name, task_impl in tasks.items():
            register_task_class(task_name, task_impl)

    def load_flow_imported_functions(self, functions):
        &#34;&#34;&#34;Load the `import.functions` attribute.&#34;&#34;&#34;
        for func_name, func_import in functions.items():
            self.load_function(func_name, func_import)

    def load_flow_imports(self, imports):
        &#34;&#34;&#34;Load the `import` block.&#34;&#34;&#34;
        for _import in imports:
            self.load_flow_imported_tasks(_import.get(&#34;tasks&#34;, []))
            self.load_flow_imported_functions(_import.get(&#34;functions&#34;, {}))

    def load_flow_tasks(self, tasks):
        for task in self.load_flow_tasks_from_spec(tasks):
            self.add_task(task)

    def load_flow_spec_body(self, spec):
        &#34;&#34;&#34;Load the body of a flow block.&#34;&#34;&#34;
        self.load_flow_imports(spec.get(&#34;import&#34;, []))
        self.load_flow_variables(spec.get(&#34;variable&#34;, []))
        self.load_flow_tasks(spec.get(&#34;task&#34;, []))
        self.set_tasks_dependencies()

    def make_run_context(self, vars=None):
        &#34;&#34;&#34;Prepare the context for a task run.&#34;&#34;&#34;
        context = {
            &#34;var&#34;: dict(self.vars, **dict(vars or {})),
            &#34;task&#34;: {},
            &#34;func&#34;: self.functions,
        }
        for task in self:
            context[&#34;task&#34;].setdefault(task.type, {})
            context[&#34;task&#34;][task.type].setdefault(task.name, {})
        return context

    def as_task(self, vars=None):
        return FlowRunTask(flow=self, vars=vars)

    async def run(self, vars=None):
        &#34;&#34;&#34;Run a flow.&#34;&#34;&#34;
        context = self.make_run_context(vars)
        await self.runner.run(context)
        return context</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="runflow.core.Flow"><code class="flex name class">
<span>class <span class="ident">Flow</span></span>
<span>(</span><span>name, runner_cls=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Flow object manages the flow graph and the order of task executions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Flow:
    &#34;&#34;&#34;Flow object manages the flow graph and the order of task executions.&#34;&#34;&#34;

    def __init__(self, name, runner_cls=None):
        self.name = name
        self.graph = networkx.DiGraph()
        self.runner = (runner_cls or SequentialRunner)(self)
        self.vars = {}
        self.functions = {}

    def __iter__(self):
        &#34;&#34;&#34;Iterate through all tasks in a dependent order.&#34;&#34;&#34;
        try:
            yield from networkx.topological_sort(self.graph)
        except networkx.exception.NetworkXUnfeasible as err:
            raise RunflowAcyclicTasksError(str(err)) from err

    @property
    def exception(self):
        return next(
            (
                task_result.exception
                for task_result in self.runner.results.values()
                if task_result.status == TaskStatus.FAILED
            ),
            None,
        )

    @classmethod
    def from_spec(cls, source):
        &#34;&#34;&#34;Load flow from a .hcl file content.&#34;&#34;&#34;
        try:
            flow = hcl2.loads(source)
        except LarkError as err:
            raise RunflowSyntaxError(str(err)) from err

        assert &#34;flow&#34; in flow, &#34;Need a flow block&#34;
        assert len(flow[&#34;flow&#34;]) == 1, &#34;Runflow spec should have only one flow&#34;

        flow_spec = flow[&#34;flow&#34;][0]
        flow_name, flow_body = next(iter(flow_spec.items()))
        flow = cls(name=flow_name)
        flow.load_flow_spec_body(flow_body)
        return flow

    @classmethod
    def from_specfile(cls, path):
        &#34;&#34;&#34;Load flow from a given file path.&#34;&#34;&#34;
        with open(path) as file:
            flow_spec = file.read()
        return cls.from_spec(flow_spec)

    @classmethod
    def load(cls, path=None, source=None, module=None, flow=None):
        if path:
            return Flow.from_specfile(path)

        if source:
            return Flow.from_spec(source)

        if module:
            return import_module(module)

        return flow

    def add_task(self, task):
        &#34;&#34;&#34;Add task to flow graph.&#34;&#34;&#34;
        self.graph.add_node(task)

    def set_dependency(self, task, depends_on):
        &#34;&#34;&#34;Let `task` depends on `depends_on`,

        e.g. `depends_on` is a predecessor edge of `task`.

        &#34;&#34;&#34;
        self.graph.add_edge(depends_on, task)

    def set_default_var(self, name, value):
        &#34;&#34;&#34;Set default value for variable.&#34;&#34;&#34;
        self.vars[name] = value

    def load_function(self, func_name, import_string):
        &#34;&#34;&#34;Load the imported function to task func namespace.&#34;&#34;&#34;
        function = utils.import_module(import_string)
        self.functions[func_name] = function

    # pylint: disable=no-self-use
    def load_flow_tasks_from_spec(self, tasks_spec):
        &#34;&#34;&#34;Load the `task` blocks.&#34;&#34;&#34;
        for task_spec in tasks_spec:
            for task_type in task_spec:
                task_class = get_task_class(task_type)
                for task_name in task_spec[task_type]:
                    task_payload = dict(task_spec[task_type][task_name])
                    yield Task(task_type, task_class, task_name, task_payload)

    def load_task_by_task_reference(self, depends_on):
        &#34;&#34;&#34;Find task by a reference like `task.TASK_TYPE.TASK_NAME`.&#34;&#34;&#34;
        task_key = depends_on.split(&#34;.&#34;)
        assert len(task_key) == 3 and task_key[0] == &#34;task&#34;

        _, task_type, task_name = task_key

        for task in self.graph.nodes:
            if task.type == task_type and task.name == task_name:
                return task

        raise RunflowSyntaxError(
            f&#34;Task depends on {task_key} &#34;
            f&#34;but the dependent task does not exist&#34;
        )

    def load_flow_tasks_dependencies(self, task):
        &#34;&#34;&#34;Find task dependencies.&#34;&#34;&#34;
        deps_set = set()
        for key, value in task.payload.items():
            hcl2.resolve_deps(key, deps_set)
            hcl2.resolve_deps(value, deps_set)

        for dep in deps_set:
            yield self.load_task_by_task_reference(dep)

    def set_tasks_dependencies(self):
        &#34;&#34;&#34;Walk the task graph and sort out the task dependencies.&#34;&#34;&#34;
        for task in self.graph.nodes:
            explicit_deps = self.load_flow_tasks_dependencies(task)
            for dep in explicit_deps:
                self.set_dependency(task, dep)

    def load_flow_variables(self, vars_spec):
        &#34;&#34;&#34;Load the `variable` block.&#34;&#34;&#34;
        for var_spec in vars_spec:
            var_name = next(iter(var_spec.keys()))
            var_value_spec = next(iter(var_spec.values()))
            var_value = config(
                f&#34;RUNFLOW_VAR_{var_name}&#34;, default=None
            ) or var_value_spec.get(&#34;default&#34;, None)
            var_required = var_value_spec.get(&#34;required&#34;)
            if var_required and var_value is None:
                raise NameError(f&#34;{var_name} is required but not provided.&#34;)
            self.set_default_var(var_name, var_value)

    # pylint: disable=no-self-use
    def load_flow_imported_tasks(self, tasks):
        &#34;&#34;&#34;Load the `import.tasks` attribute.&#34;&#34;&#34;
        for task_name, task_impl in tasks.items():
            register_task_class(task_name, task_impl)

    def load_flow_imported_functions(self, functions):
        &#34;&#34;&#34;Load the `import.functions` attribute.&#34;&#34;&#34;
        for func_name, func_import in functions.items():
            self.load_function(func_name, func_import)

    def load_flow_imports(self, imports):
        &#34;&#34;&#34;Load the `import` block.&#34;&#34;&#34;
        for _import in imports:
            self.load_flow_imported_tasks(_import.get(&#34;tasks&#34;, []))
            self.load_flow_imported_functions(_import.get(&#34;functions&#34;, {}))

    def load_flow_tasks(self, tasks):
        for task in self.load_flow_tasks_from_spec(tasks):
            self.add_task(task)

    def load_flow_spec_body(self, spec):
        &#34;&#34;&#34;Load the body of a flow block.&#34;&#34;&#34;
        self.load_flow_imports(spec.get(&#34;import&#34;, []))
        self.load_flow_variables(spec.get(&#34;variable&#34;, []))
        self.load_flow_tasks(spec.get(&#34;task&#34;, []))
        self.set_tasks_dependencies()

    def make_run_context(self, vars=None):
        &#34;&#34;&#34;Prepare the context for a task run.&#34;&#34;&#34;
        context = {
            &#34;var&#34;: dict(self.vars, **dict(vars or {})),
            &#34;task&#34;: {},
            &#34;func&#34;: self.functions,
        }
        for task in self:
            context[&#34;task&#34;].setdefault(task.type, {})
            context[&#34;task&#34;][task.type].setdefault(task.name, {})
        return context

    def as_task(self, vars=None):
        return FlowRunTask(flow=self, vars=vars)

    async def run(self, vars=None):
        &#34;&#34;&#34;Run a flow.&#34;&#34;&#34;
        context = self.make_run_context(vars)
        await self.runner.run(context)
        return context</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="runflow.core.Flow.from_spec"><code class="name flex">
<span>def <span class="ident">from_spec</span></span>(<span>source)</span>
</code></dt>
<dd>
<div class="desc"><p>Load flow from a .hcl file content.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_spec(cls, source):
    &#34;&#34;&#34;Load flow from a .hcl file content.&#34;&#34;&#34;
    try:
        flow = hcl2.loads(source)
    except LarkError as err:
        raise RunflowSyntaxError(str(err)) from err

    assert &#34;flow&#34; in flow, &#34;Need a flow block&#34;
    assert len(flow[&#34;flow&#34;]) == 1, &#34;Runflow spec should have only one flow&#34;

    flow_spec = flow[&#34;flow&#34;][0]
    flow_name, flow_body = next(iter(flow_spec.items()))
    flow = cls(name=flow_name)
    flow.load_flow_spec_body(flow_body)
    return flow</code></pre>
</details>
</dd>
<dt id="runflow.core.Flow.from_specfile"><code class="name flex">
<span>def <span class="ident">from_specfile</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"><p>Load flow from a given file path.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_specfile(cls, path):
    &#34;&#34;&#34;Load flow from a given file path.&#34;&#34;&#34;
    with open(path) as file:
        flow_spec = file.read()
    return cls.from_spec(flow_spec)</code></pre>
</details>
</dd>
<dt id="runflow.core.Flow.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>path=None, source=None, module=None, flow=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def load(cls, path=None, source=None, module=None, flow=None):
    if path:
        return Flow.from_specfile(path)

    if source:
        return Flow.from_spec(source)

    if module:
        return import_module(module)

    return flow</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="runflow.core.Flow.exception"><code class="name">var <span class="ident">exception</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def exception(self):
    return next(
        (
            task_result.exception
            for task_result in self.runner.results.values()
            if task_result.status == TaskStatus.FAILED
        ),
        None,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="runflow.core.Flow.add_task"><code class="name flex">
<span>def <span class="ident">add_task</span></span>(<span>self, task)</span>
</code></dt>
<dd>
<div class="desc"><p>Add task to flow graph.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_task(self, task):
    &#34;&#34;&#34;Add task to flow graph.&#34;&#34;&#34;
    self.graph.add_node(task)</code></pre>
</details>
</dd>
<dt id="runflow.core.Flow.as_task"><code class="name flex">
<span>def <span class="ident">as_task</span></span>(<span>self, vars=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_task(self, vars=None):
    return FlowRunTask(flow=self, vars=vars)</code></pre>
</details>
</dd>
<dt id="runflow.core.Flow.load_flow_imported_functions"><code class="name flex">
<span>def <span class="ident">load_flow_imported_functions</span></span>(<span>self, functions)</span>
</code></dt>
<dd>
<div class="desc"><p>Load the <code>import.functions</code> attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_flow_imported_functions(self, functions):
    &#34;&#34;&#34;Load the `import.functions` attribute.&#34;&#34;&#34;
    for func_name, func_import in functions.items():
        self.load_function(func_name, func_import)</code></pre>
</details>
</dd>
<dt id="runflow.core.Flow.load_flow_imported_tasks"><code class="name flex">
<span>def <span class="ident">load_flow_imported_tasks</span></span>(<span>self, tasks)</span>
</code></dt>
<dd>
<div class="desc"><p>Load the <code>import.tasks</code> attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_flow_imported_tasks(self, tasks):
    &#34;&#34;&#34;Load the `import.tasks` attribute.&#34;&#34;&#34;
    for task_name, task_impl in tasks.items():
        register_task_class(task_name, task_impl)</code></pre>
</details>
</dd>
<dt id="runflow.core.Flow.load_flow_imports"><code class="name flex">
<span>def <span class="ident">load_flow_imports</span></span>(<span>self, imports)</span>
</code></dt>
<dd>
<div class="desc"><p>Load the <code>import</code> block.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_flow_imports(self, imports):
    &#34;&#34;&#34;Load the `import` block.&#34;&#34;&#34;
    for _import in imports:
        self.load_flow_imported_tasks(_import.get(&#34;tasks&#34;, []))
        self.load_flow_imported_functions(_import.get(&#34;functions&#34;, {}))</code></pre>
</details>
</dd>
<dt id="runflow.core.Flow.load_flow_spec_body"><code class="name flex">
<span>def <span class="ident">load_flow_spec_body</span></span>(<span>self, spec)</span>
</code></dt>
<dd>
<div class="desc"><p>Load the body of a flow block.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_flow_spec_body(self, spec):
    &#34;&#34;&#34;Load the body of a flow block.&#34;&#34;&#34;
    self.load_flow_imports(spec.get(&#34;import&#34;, []))
    self.load_flow_variables(spec.get(&#34;variable&#34;, []))
    self.load_flow_tasks(spec.get(&#34;task&#34;, []))
    self.set_tasks_dependencies()</code></pre>
</details>
</dd>
<dt id="runflow.core.Flow.load_flow_tasks"><code class="name flex">
<span>def <span class="ident">load_flow_tasks</span></span>(<span>self, tasks)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_flow_tasks(self, tasks):
    for task in self.load_flow_tasks_from_spec(tasks):
        self.add_task(task)</code></pre>
</details>
</dd>
<dt id="runflow.core.Flow.load_flow_tasks_dependencies"><code class="name flex">
<span>def <span class="ident">load_flow_tasks_dependencies</span></span>(<span>self, task)</span>
</code></dt>
<dd>
<div class="desc"><p>Find task dependencies.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_flow_tasks_dependencies(self, task):
    &#34;&#34;&#34;Find task dependencies.&#34;&#34;&#34;
    deps_set = set()
    for key, value in task.payload.items():
        hcl2.resolve_deps(key, deps_set)
        hcl2.resolve_deps(value, deps_set)

    for dep in deps_set:
        yield self.load_task_by_task_reference(dep)</code></pre>
</details>
</dd>
<dt id="runflow.core.Flow.load_flow_tasks_from_spec"><code class="name flex">
<span>def <span class="ident">load_flow_tasks_from_spec</span></span>(<span>self, tasks_spec)</span>
</code></dt>
<dd>
<div class="desc"><p>Load the <code>task</code> blocks.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_flow_tasks_from_spec(self, tasks_spec):
    &#34;&#34;&#34;Load the `task` blocks.&#34;&#34;&#34;
    for task_spec in tasks_spec:
        for task_type in task_spec:
            task_class = get_task_class(task_type)
            for task_name in task_spec[task_type]:
                task_payload = dict(task_spec[task_type][task_name])
                yield Task(task_type, task_class, task_name, task_payload)</code></pre>
</details>
</dd>
<dt id="runflow.core.Flow.load_flow_variables"><code class="name flex">
<span>def <span class="ident">load_flow_variables</span></span>(<span>self, vars_spec)</span>
</code></dt>
<dd>
<div class="desc"><p>Load the <code>variable</code> block.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_flow_variables(self, vars_spec):
    &#34;&#34;&#34;Load the `variable` block.&#34;&#34;&#34;
    for var_spec in vars_spec:
        var_name = next(iter(var_spec.keys()))
        var_value_spec = next(iter(var_spec.values()))
        var_value = config(
            f&#34;RUNFLOW_VAR_{var_name}&#34;, default=None
        ) or var_value_spec.get(&#34;default&#34;, None)
        var_required = var_value_spec.get(&#34;required&#34;)
        if var_required and var_value is None:
            raise NameError(f&#34;{var_name} is required but not provided.&#34;)
        self.set_default_var(var_name, var_value)</code></pre>
</details>
</dd>
<dt id="runflow.core.Flow.load_function"><code class="name flex">
<span>def <span class="ident">load_function</span></span>(<span>self, func_name, import_string)</span>
</code></dt>
<dd>
<div class="desc"><p>Load the imported function to task func namespace.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_function(self, func_name, import_string):
    &#34;&#34;&#34;Load the imported function to task func namespace.&#34;&#34;&#34;
    function = utils.import_module(import_string)
    self.functions[func_name] = function</code></pre>
</details>
</dd>
<dt id="runflow.core.Flow.load_task_by_task_reference"><code class="name flex">
<span>def <span class="ident">load_task_by_task_reference</span></span>(<span>self, depends_on)</span>
</code></dt>
<dd>
<div class="desc"><p>Find task by a reference like <code>task.TASK_TYPE.TASK_NAME</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_task_by_task_reference(self, depends_on):
    &#34;&#34;&#34;Find task by a reference like `task.TASK_TYPE.TASK_NAME`.&#34;&#34;&#34;
    task_key = depends_on.split(&#34;.&#34;)
    assert len(task_key) == 3 and task_key[0] == &#34;task&#34;

    _, task_type, task_name = task_key

    for task in self.graph.nodes:
        if task.type == task_type and task.name == task_name:
            return task

    raise RunflowSyntaxError(
        f&#34;Task depends on {task_key} &#34;
        f&#34;but the dependent task does not exist&#34;
    )</code></pre>
</details>
</dd>
<dt id="runflow.core.Flow.make_run_context"><code class="name flex">
<span>def <span class="ident">make_run_context</span></span>(<span>self, vars=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Prepare the context for a task run.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_run_context(self, vars=None):
    &#34;&#34;&#34;Prepare the context for a task run.&#34;&#34;&#34;
    context = {
        &#34;var&#34;: dict(self.vars, **dict(vars or {})),
        &#34;task&#34;: {},
        &#34;func&#34;: self.functions,
    }
    for task in self:
        context[&#34;task&#34;].setdefault(task.type, {})
        context[&#34;task&#34;][task.type].setdefault(task.name, {})
    return context</code></pre>
</details>
</dd>
<dt id="runflow.core.Flow.run"><code class="name flex">
<span>async def <span class="ident">run</span></span>(<span>self, vars=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Run a flow.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def run(self, vars=None):
    &#34;&#34;&#34;Run a flow.&#34;&#34;&#34;
    context = self.make_run_context(vars)
    await self.runner.run(context)
    return context</code></pre>
</details>
</dd>
<dt id="runflow.core.Flow.set_default_var"><code class="name flex">
<span>def <span class="ident">set_default_var</span></span>(<span>self, name, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Set default value for variable.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_default_var(self, name, value):
    &#34;&#34;&#34;Set default value for variable.&#34;&#34;&#34;
    self.vars[name] = value</code></pre>
</details>
</dd>
<dt id="runflow.core.Flow.set_dependency"><code class="name flex">
<span>def <span class="ident">set_dependency</span></span>(<span>self, task, depends_on)</span>
</code></dt>
<dd>
<div class="desc"><p>Let <code>task</code> depends on <code>depends_on</code>,</p>
<p>e.g. <code>depends_on</code> is a predecessor edge of <code>task</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_dependency(self, task, depends_on):
    &#34;&#34;&#34;Let `task` depends on `depends_on`,

    e.g. `depends_on` is a predecessor edge of `task`.

    &#34;&#34;&#34;
    self.graph.add_edge(depends_on, task)</code></pre>
</details>
</dd>
<dt id="runflow.core.Flow.set_tasks_dependencies"><code class="name flex">
<span>def <span class="ident">set_tasks_dependencies</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Walk the task graph and sort out the task dependencies.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_tasks_dependencies(self):
    &#34;&#34;&#34;Walk the task graph and sort out the task dependencies.&#34;&#34;&#34;
    for task in self.graph.nodes:
        explicit_deps = self.load_flow_tasks_dependencies(task)
        for dep in explicit_deps:
            self.set_dependency(task, dep)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="runflow.core.FlowRunTask"><code class="flex name class">
<span>class <span class="ident">FlowRunTask</span></span>
<span>(</span><span>path=None, source=None, module=None, flow=None, vars=None, export=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FlowRunTask:
    def __init__(
        self,
        path=None,
        source=None,
        module=None,
        flow=None,
        vars=None,
        export=None,
    ):
        self.path = path
        self.source = source
        self.module = module
        self.flow = flow
        self.vars = vars or {}
        self.export = export or []
        self.namespace = &#34;&#34;

    async def run(self):
        flow = Flow.load(
            path=self.path,
            source=self.source,
            module=self.module,
            flow=self.flow,
        )
        for task in flow:
            task.set_namespace(self.namespace)

        flow_context = await flow.run(vars=self.vars)

        if flow.exception:
            raise flow.exception

        return {
            key: hcl2.evaluate(hcl2.loads(value, &#34;eval&#34;), flow_context)
            for export in self.export
            for key, value in export.items()
        }</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="runflow.core.FlowRunTask.run"><code class="name flex">
<span>async def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def run(self):
    flow = Flow.load(
        path=self.path,
        source=self.source,
        module=self.module,
        flow=self.flow,
    )
    for task in flow:
        task.set_namespace(self.namespace)

    flow_context = await flow.run(vars=self.vars)

    if flow.exception:
        raise flow.exception

    return {
        key: hcl2.evaluate(hcl2.loads(value, &#34;eval&#34;), flow_context)
        for export in self.export
        for key, value in export.items()
    }</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="runflow.core.SequentialRunner"><code class="flex name class">
<span>class <span class="ident">SequentialRunner</span></span>
<span>(</span><span>flow)</span>
</code></dt>
<dd>
<div class="desc"><p>This runner runs the flow tasks sequentially.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SequentialRunner:
    &#34;&#34;&#34;This runner runs the flow tasks sequentially.&#34;&#34;&#34;

    def __init__(self, flow):
        self.flow = flow
        self.results = {}

    def check_depends_on(self, task):
        for upstream_task in self.flow.graph.predecessors(task):
            if self.results[upstream_task].status in (
                TaskStatus.FAILED,
                TaskStatus.CANCELED,
            ):
                return False
        return True

    async def run_task(self, task, context):
        if not self.check_depends_on(task):
            logger.info(
                &#39;&#34;%s&#34; is canceled due to previous task failed run.&#39;,
                f&#34;task.{task.type}.{task.name}&#34;,
            )
            return TaskResult(TaskStatus.CANCELED)

        task_result = await task.run(context)

        if task_result.status == TaskStatus.SUCCESS:
            context[&#34;task&#34;][task.type][task.name] = task_result.result

        return task_result

    async def run(self, context):
        &#34;&#34;&#34;Run flow tasks.&#34;&#34;&#34;
        for task in self.flow:
            self.results[task] = await self.run_task(task, context)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="runflow.core.SequentialRunner.check_depends_on"><code class="name flex">
<span>def <span class="ident">check_depends_on</span></span>(<span>self, task)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_depends_on(self, task):
    for upstream_task in self.flow.graph.predecessors(task):
        if self.results[upstream_task].status in (
            TaskStatus.FAILED,
            TaskStatus.CANCELED,
        ):
            return False
    return True</code></pre>
</details>
</dd>
<dt id="runflow.core.SequentialRunner.run"><code class="name flex">
<span>async def <span class="ident">run</span></span>(<span>self, context)</span>
</code></dt>
<dd>
<div class="desc"><p>Run flow tasks.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def run(self, context):
    &#34;&#34;&#34;Run flow tasks.&#34;&#34;&#34;
    for task in self.flow:
        self.results[task] = await self.run_task(task, context)</code></pre>
</details>
</dd>
<dt id="runflow.core.SequentialRunner.run_task"><code class="name flex">
<span>async def <span class="ident">run_task</span></span>(<span>self, task, context)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def run_task(self, task, context):
    if not self.check_depends_on(task):
        logger.info(
            &#39;&#34;%s&#34; is canceled due to previous task failed run.&#39;,
            f&#34;task.{task.type}.{task.name}&#34;,
        )
        return TaskResult(TaskStatus.CANCELED)

    task_result = await task.run(context)

    if task_result.status == TaskStatus.SUCCESS:
        context[&#34;task&#34;][task.type][task.name] = task_result.result

    return task_result</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="runflow.core.Task"><code class="flex name class">
<span>class <span class="ident">Task</span></span>
<span>(</span><span>type, runner, name, payload)</span>
</code></dt>
<dd>
<div class="desc"><p>Task object maintains the running status.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Task:
    &#34;&#34;&#34;Task object maintains the running status.&#34;&#34;&#34;

    def __init__(self, type, runner, name, payload):
        self.type = type
        self.runner = runner
        self.name = name
        self.payload = payload
        self.namespace = &#34;&#34;

    def __repr__(self):
        return (
            f&#34;Task(type={self.type}, &#34;
            f&#34;name={self.name}, &#34;
            f&#34;payload={self.payload})&#34;
        )

    def __str__(self):
        return (
            f&#34;{self.namespace}{self.namespace and &#39; &gt; &#39; or &#39;&#39;}&#34;
            f&#34;task.{self.type}.{self.name}&#34;
        )

    def __hash__(self):
        return hash(repr(self))

    def __eq__(self, o):
        return self.type == o.type and self.name == o.name

    def set_namespace(self, namespace):
        self.namespace = namespace

    def should_run(self, context):
        return all(
            hcl2.evaluate(depends_on, context)
            for depends_on in self.payload.get(DEPENDS_ON_KEY, [])
        )

    def should_timeout(self, task, context):
        if &#34;_timeout&#34; not in self.payload:
            return None
        _timeout = hcl2.evaluate(self.payload[&#34;_timeout&#34;], context)
        assert isinstance(_timeout, (int, float))
        return _timeout

    def should_rerun(self, task, context):  # pylint: disable=too-many-branches
        if &#34;_retry&#34; not in self.payload:
            return task.run

        _retry = hcl2.evaluate(self.payload.get(&#34;_retry&#34;, {}), context)
        _retry_params = {}
        stop_after = _retry.get(&#34;stop_after&#34;, &#34;1 times&#34;)
        stopers = []
        for _stop_after in stop_after.split(&#34;|&#34;):
            _stop_after = _stop_after.strip()
            if &#34;times&#34; in _stop_after:
                attempts = int(_stop_after.replace(&#34;times&#34;, &#34;&#34;).strip())
                stoper = stop_after_attempt(attempts)
            elif &#34;seconds&#34; in _stop_after:
                seconds = float(_stop_after.replace(&#34;seconds&#34;, &#34;&#34;).strip())
                stoper = stop_after_delay(seconds)
            else:
                raise ValueError(f&#34;invalid _retry.stop_after: {_stop_after}&#34;)
            stopers.append(stoper)

        _retry_params[&#34;stop&#34;] = reduce(lambda a, b: a | b, stopers)
        _retry_params[&#34;wait&#34;] = _retry.get(&#34;wait&#34;, None)
        _retry_params[&#34;reraise&#34;] = True
        return retry(**_retry_params)(task.run)

    def eval_payload(self, context):
        return hcl2.evaluate(
            {k: v for k, v in self.payload.items() if not k.startswith(&#34;_&#34;)},
            context,
        )

    async def run(self, context):
        &#34;&#34;&#34;Run a task.&#34;&#34;&#34;
        if self.type == &#34;hcl2_template&#34;:
            context = dict(
                context,
                **hcl2.evaluate(self.payload.get(&#34;context&#34;, {}), context),
            )

        if not self.should_run(context):
            logger.info(&#39;&#34;%s&#34; is canceled due to falsy deps.&#39;, str(self))
            return TaskResult(TaskStatus.CANCELED)

        _payload = self.eval_payload(context)
        context[&#34;task&#34;][self.type][self.name].update(_payload)

        task_result = TaskResult(TaskStatus.PENDING)

        try:
            logger.info(&#39;&#34;%s&#34; is started.&#39;, str(self))
            if isinstance(self.runner, Flow):
                task = self.runner.as_task(_payload)
            else:
                task = self.runner(**_payload)

            if isinstance(task, FlowRunTask):
                task.namespace = str(self)

            task_run = self.should_rerun(task, context)
            task_result.result = (
                await asyncio.wait_for(
                    task_run()
                    if inspect.iscoroutinefunction(task.run)
                    else utils.to_thread(task_run),
                    timeout=self.should_timeout(task, context),
                )
                or {}
            )
            task_result.result.update(_payload)
            logger.info(&#39;&#34;%s&#34; is successful.&#39;, str(self))
        except Exception as err:  # pylint: disable=broad-except
            task_result.exception = err
            logger.info(&#39;&#34;%s&#34; is failed.&#39;, str(self))
            traceback.print_exc()

        return task_result</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="runflow.core.Task.eval_payload"><code class="name flex">
<span>def <span class="ident">eval_payload</span></span>(<span>self, context)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eval_payload(self, context):
    return hcl2.evaluate(
        {k: v for k, v in self.payload.items() if not k.startswith(&#34;_&#34;)},
        context,
    )</code></pre>
</details>
</dd>
<dt id="runflow.core.Task.run"><code class="name flex">
<span>async def <span class="ident">run</span></span>(<span>self, context)</span>
</code></dt>
<dd>
<div class="desc"><p>Run a task.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def run(self, context):
    &#34;&#34;&#34;Run a task.&#34;&#34;&#34;
    if self.type == &#34;hcl2_template&#34;:
        context = dict(
            context,
            **hcl2.evaluate(self.payload.get(&#34;context&#34;, {}), context),
        )

    if not self.should_run(context):
        logger.info(&#39;&#34;%s&#34; is canceled due to falsy deps.&#39;, str(self))
        return TaskResult(TaskStatus.CANCELED)

    _payload = self.eval_payload(context)
    context[&#34;task&#34;][self.type][self.name].update(_payload)

    task_result = TaskResult(TaskStatus.PENDING)

    try:
        logger.info(&#39;&#34;%s&#34; is started.&#39;, str(self))
        if isinstance(self.runner, Flow):
            task = self.runner.as_task(_payload)
        else:
            task = self.runner(**_payload)

        if isinstance(task, FlowRunTask):
            task.namespace = str(self)

        task_run = self.should_rerun(task, context)
        task_result.result = (
            await asyncio.wait_for(
                task_run()
                if inspect.iscoroutinefunction(task.run)
                else utils.to_thread(task_run),
                timeout=self.should_timeout(task, context),
            )
            or {}
        )
        task_result.result.update(_payload)
        logger.info(&#39;&#34;%s&#34; is successful.&#39;, str(self))
    except Exception as err:  # pylint: disable=broad-except
        task_result.exception = err
        logger.info(&#39;&#34;%s&#34; is failed.&#39;, str(self))
        traceback.print_exc()

    return task_result</code></pre>
</details>
</dd>
<dt id="runflow.core.Task.set_namespace"><code class="name flex">
<span>def <span class="ident">set_namespace</span></span>(<span>self, namespace)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_namespace(self, namespace):
    self.namespace = namespace</code></pre>
</details>
</dd>
<dt id="runflow.core.Task.should_rerun"><code class="name flex">
<span>def <span class="ident">should_rerun</span></span>(<span>self, task, context)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def should_rerun(self, task, context):  # pylint: disable=too-many-branches
    if &#34;_retry&#34; not in self.payload:
        return task.run

    _retry = hcl2.evaluate(self.payload.get(&#34;_retry&#34;, {}), context)
    _retry_params = {}
    stop_after = _retry.get(&#34;stop_after&#34;, &#34;1 times&#34;)
    stopers = []
    for _stop_after in stop_after.split(&#34;|&#34;):
        _stop_after = _stop_after.strip()
        if &#34;times&#34; in _stop_after:
            attempts = int(_stop_after.replace(&#34;times&#34;, &#34;&#34;).strip())
            stoper = stop_after_attempt(attempts)
        elif &#34;seconds&#34; in _stop_after:
            seconds = float(_stop_after.replace(&#34;seconds&#34;, &#34;&#34;).strip())
            stoper = stop_after_delay(seconds)
        else:
            raise ValueError(f&#34;invalid _retry.stop_after: {_stop_after}&#34;)
        stopers.append(stoper)

    _retry_params[&#34;stop&#34;] = reduce(lambda a, b: a | b, stopers)
    _retry_params[&#34;wait&#34;] = _retry.get(&#34;wait&#34;, None)
    _retry_params[&#34;reraise&#34;] = True
    return retry(**_retry_params)(task.run)</code></pre>
</details>
</dd>
<dt id="runflow.core.Task.should_run"><code class="name flex">
<span>def <span class="ident">should_run</span></span>(<span>self, context)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def should_run(self, context):
    return all(
        hcl2.evaluate(depends_on, context)
        for depends_on in self.payload.get(DEPENDS_ON_KEY, [])
    )</code></pre>
</details>
</dd>
<dt id="runflow.core.Task.should_timeout"><code class="name flex">
<span>def <span class="ident">should_timeout</span></span>(<span>self, task, context)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def should_timeout(self, task, context):
    if &#34;_timeout&#34; not in self.payload:
        return None
    _timeout = hcl2.evaluate(self.payload[&#34;_timeout&#34;], context)
    assert isinstance(_timeout, (int, float))
    return _timeout</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="runflow.core.TaskResult"><code class="flex name class">
<span>class <span class="ident">TaskResult</span></span>
<span>(</span><span>status)</span>
</code></dt>
<dd>
<div class="desc"><p>Task execution result.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TaskResult:
    &#34;&#34;&#34;Task execution result.&#34;&#34;&#34;

    def __init__(self, status):
        self.status = status
        self._result = None
        self._exception = None

    @property
    def result(self):
        &#34;&#34;&#34;Get task result.&#34;&#34;&#34;
        if self._exception:
            raise ValueError(
                &#34;Task has no result due to a failed run.&#34;
            ) from self._exception
        return self._result

    @result.setter
    def result(self, _result):
        &#34;&#34;&#34;Set task result.&#34;&#34;&#34;
        self.status = TaskStatus.SUCCESS
        self._result = _result

    @property
    def exception(self):
        &#34;&#34;&#34;Get task exception.&#34;&#34;&#34;
        if self._result:
            raise ValueError(&#34;Task has no exception due to a successful run.&#34;)
        return self._exception

    @exception.setter
    def exception(self, _exception):
        &#34;&#34;&#34;Set task exception.&#34;&#34;&#34;
        self.status = TaskStatus.FAILED
        self._exception = _exception</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="runflow.core.TaskResult.exception"><code class="name">var <span class="ident">exception</span></code></dt>
<dd>
<div class="desc"><p>Get task exception.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def exception(self):
    &#34;&#34;&#34;Get task exception.&#34;&#34;&#34;
    if self._result:
        raise ValueError(&#34;Task has no exception due to a successful run.&#34;)
    return self._exception</code></pre>
</details>
</dd>
<dt id="runflow.core.TaskResult.result"><code class="name">var <span class="ident">result</span></code></dt>
<dd>
<div class="desc"><p>Get task result.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def result(self):
    &#34;&#34;&#34;Get task result.&#34;&#34;&#34;
    if self._exception:
        raise ValueError(
            &#34;Task has no result due to a failed run.&#34;
        ) from self._exception
    return self._result</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="runflow.core.TaskStatus"><code class="flex name class">
<span>class <span class="ident">TaskStatus</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Task execution status.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TaskStatus(enum.Enum):
    &#34;&#34;&#34;Task execution status.&#34;&#34;&#34;

    PENDING = enum.auto()
    SUCCESS = enum.auto()
    FAILED = enum.auto()
    CANCELED = enum.auto()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="runflow.core.TaskStatus.CANCELED"><code class="name">var <span class="ident">CANCELED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="runflow.core.TaskStatus.FAILED"><code class="name">var <span class="ident">FAILED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="runflow.core.TaskStatus.PENDING"><code class="name">var <span class="ident">PENDING</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="runflow.core.TaskStatus.SUCCESS"><code class="name">var <span class="ident">SUCCESS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="runflow" href="index.html">runflow</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="runflow.core.Flow" href="#runflow.core.Flow">Flow</a></code></h4>
<ul class="">
<li><code><a title="runflow.core.Flow.add_task" href="#runflow.core.Flow.add_task">add_task</a></code></li>
<li><code><a title="runflow.core.Flow.as_task" href="#runflow.core.Flow.as_task">as_task</a></code></li>
<li><code><a title="runflow.core.Flow.exception" href="#runflow.core.Flow.exception">exception</a></code></li>
<li><code><a title="runflow.core.Flow.from_spec" href="#runflow.core.Flow.from_spec">from_spec</a></code></li>
<li><code><a title="runflow.core.Flow.from_specfile" href="#runflow.core.Flow.from_specfile">from_specfile</a></code></li>
<li><code><a title="runflow.core.Flow.load" href="#runflow.core.Flow.load">load</a></code></li>
<li><code><a title="runflow.core.Flow.load_flow_imported_functions" href="#runflow.core.Flow.load_flow_imported_functions">load_flow_imported_functions</a></code></li>
<li><code><a title="runflow.core.Flow.load_flow_imported_tasks" href="#runflow.core.Flow.load_flow_imported_tasks">load_flow_imported_tasks</a></code></li>
<li><code><a title="runflow.core.Flow.load_flow_imports" href="#runflow.core.Flow.load_flow_imports">load_flow_imports</a></code></li>
<li><code><a title="runflow.core.Flow.load_flow_spec_body" href="#runflow.core.Flow.load_flow_spec_body">load_flow_spec_body</a></code></li>
<li><code><a title="runflow.core.Flow.load_flow_tasks" href="#runflow.core.Flow.load_flow_tasks">load_flow_tasks</a></code></li>
<li><code><a title="runflow.core.Flow.load_flow_tasks_dependencies" href="#runflow.core.Flow.load_flow_tasks_dependencies">load_flow_tasks_dependencies</a></code></li>
<li><code><a title="runflow.core.Flow.load_flow_tasks_from_spec" href="#runflow.core.Flow.load_flow_tasks_from_spec">load_flow_tasks_from_spec</a></code></li>
<li><code><a title="runflow.core.Flow.load_flow_variables" href="#runflow.core.Flow.load_flow_variables">load_flow_variables</a></code></li>
<li><code><a title="runflow.core.Flow.load_function" href="#runflow.core.Flow.load_function">load_function</a></code></li>
<li><code><a title="runflow.core.Flow.load_task_by_task_reference" href="#runflow.core.Flow.load_task_by_task_reference">load_task_by_task_reference</a></code></li>
<li><code><a title="runflow.core.Flow.make_run_context" href="#runflow.core.Flow.make_run_context">make_run_context</a></code></li>
<li><code><a title="runflow.core.Flow.run" href="#runflow.core.Flow.run">run</a></code></li>
<li><code><a title="runflow.core.Flow.set_default_var" href="#runflow.core.Flow.set_default_var">set_default_var</a></code></li>
<li><code><a title="runflow.core.Flow.set_dependency" href="#runflow.core.Flow.set_dependency">set_dependency</a></code></li>
<li><code><a title="runflow.core.Flow.set_tasks_dependencies" href="#runflow.core.Flow.set_tasks_dependencies">set_tasks_dependencies</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="runflow.core.FlowRunTask" href="#runflow.core.FlowRunTask">FlowRunTask</a></code></h4>
<ul class="">
<li><code><a title="runflow.core.FlowRunTask.run" href="#runflow.core.FlowRunTask.run">run</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="runflow.core.SequentialRunner" href="#runflow.core.SequentialRunner">SequentialRunner</a></code></h4>
<ul class="">
<li><code><a title="runflow.core.SequentialRunner.check_depends_on" href="#runflow.core.SequentialRunner.check_depends_on">check_depends_on</a></code></li>
<li><code><a title="runflow.core.SequentialRunner.run" href="#runflow.core.SequentialRunner.run">run</a></code></li>
<li><code><a title="runflow.core.SequentialRunner.run_task" href="#runflow.core.SequentialRunner.run_task">run_task</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="runflow.core.Task" href="#runflow.core.Task">Task</a></code></h4>
<ul class="two-column">
<li><code><a title="runflow.core.Task.eval_payload" href="#runflow.core.Task.eval_payload">eval_payload</a></code></li>
<li><code><a title="runflow.core.Task.run" href="#runflow.core.Task.run">run</a></code></li>
<li><code><a title="runflow.core.Task.set_namespace" href="#runflow.core.Task.set_namespace">set_namespace</a></code></li>
<li><code><a title="runflow.core.Task.should_rerun" href="#runflow.core.Task.should_rerun">should_rerun</a></code></li>
<li><code><a title="runflow.core.Task.should_run" href="#runflow.core.Task.should_run">should_run</a></code></li>
<li><code><a title="runflow.core.Task.should_timeout" href="#runflow.core.Task.should_timeout">should_timeout</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="runflow.core.TaskResult" href="#runflow.core.TaskResult">TaskResult</a></code></h4>
<ul class="">
<li><code><a title="runflow.core.TaskResult.exception" href="#runflow.core.TaskResult.exception">exception</a></code></li>
<li><code><a title="runflow.core.TaskResult.result" href="#runflow.core.TaskResult.result">result</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="runflow.core.TaskStatus" href="#runflow.core.TaskStatus">TaskStatus</a></code></h4>
<ul class="">
<li><code><a title="runflow.core.TaskStatus.CANCELED" href="#runflow.core.TaskStatus.CANCELED">CANCELED</a></code></li>
<li><code><a title="runflow.core.TaskStatus.FAILED" href="#runflow.core.TaskStatus.FAILED">FAILED</a></code></li>
<li><code><a title="runflow.core.TaskStatus.PENDING" href="#runflow.core.TaskStatus.PENDING">PENDING</a></code></li>
<li><code><a title="runflow.core.TaskStatus.SUCCESS" href="#runflow.core.TaskStatus.SUCCESS">SUCCESS</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>